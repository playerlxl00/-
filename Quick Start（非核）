import numpy as np
import matplotlib.pyplot as plt

# ==============================
# python实现代码原封不动
# ==============================
class LinearSVM:
    """
    普通线性 SVM（无核），使用次梯度下降优化 hinge loss
    """
    def __init__(self, lr=1e-3, C=1.0, epochs=1000):
        self.lr = lr
        self.C = C
        self.epochs = epochs
        self.w = None
        self.b = 0.0

    def fit(self, X, y):
        n_samples, n_features = X.shape
        self.w = np.zeros(n_features)
        self.b = 0.0

        for _ in range(self.epochs):
            for i in range(n_samples):
                condition = y[i] * (np.dot(self.w, X[i]) + self.b) >= 1
                if condition:
                    self.w -= self.lr * self.w
                else:
                    self.w -= self.lr * (self.w - self.C * y[i] * X[i])
                    self.b += self.lr * self.C * y[i]

    def predict(self, X):
        return np.sign(np.dot(X, self.w) + self.b)


# 模拟例子
# ==============================
# 1. 构造训练数据
# ==============================
X_train = np.array([
    [2, 3],
    [1, 1],
    [2, 0],
    [0, 1]
])

y_train = np.array([1, 1, -1, -1])


# ==============================
# 2. 初始化并训练 SVM
# ==============================
svm = LinearSVM(lr=1e-3, C=1.0, epochs=100)
svm.fit(X_train, y_train)

# 打印训练后的 w 和 b
print("训练后的 w:", svm.w)
print("训练后的 b:", svm.b)


# ==============================
# 3. 测试预测
# ==============================
X_test = np.array([
    [1, 2],  # 接近 +1 类
    [2, -1]  # 接近 -1 类
])

y_pred = svm.predict(X_test)
print("预测结果:", y_pred)

# ==============================
# 4. 可视化
# ==============================
w = svm.w
b = svm.b

# 1. 绘制训练集
plt.scatter(X_train[y_train==1][:,0], X_train[y_train==1][:,1], color='red', label='+1')
plt.scatter(X_train[y_train==-1][:,0], X_train[y_train==-1][:,1], color='blue', label='-1')

# 2. 决策边界
x_min, x_max = X_train[:,0].min()-1, X_train[:,0].max()+1
x_plot = np.linspace(x_min, x_max, 100)
if w[1] != 0:
    y_plot = -(w[0]*x_plot + b)/w[1]
    plt.plot(x_plot, y_plot, 'k--', label='决策边界')

    # 间隔边界 f(x)=±1
    y_margin_pos = -(w[0]*x_plot + b - 1)/w[1]
    y_margin_neg = -(w[0]*x_plot + b + 1)/w[1]
    plt.plot(x_plot, y_margin_pos, 'k:', label='间隔边界')
    plt.plot(x_plot, y_margin_neg, 'k:')

# 3. 测试点
plt.scatter(X_test[:,0], X_test[:,1], color='green', marker='x', s=100, label='测试点')

plt.xlabel('x1')
plt.ylabel('x2')
plt.title('LinearSVM 可视化示例')
plt.legend()
plt.show()
